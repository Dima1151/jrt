## Ресторан
#### Разбираемся что делаем программа

> Официант почему-то не относит приготовленные блюда назад к столам

##### Основной класс Restaurant

* Зачем-то создает список нитей (потоков) `threads`.

* Создает объект действий официанта типа Waiter и добавляет его в поток waiter.
Добавляет поток офицанта в `threads`.

* Создает объект действий повара типа Cook и создает нить (поток) cook.
Добавляет поток повара в `threads`.

> Видимо предполагается несколько официантов и несколько поваров. Здесь не используется.

* Запускает потоки.

* Делает задержку в 2 сек и останавливает нить повара переменной
`cookTarget.continueWorking = false;`

* Делает задержку в 0,5 сек и останавливает нить официанта переменной
`waiterTarget.continueWorking = false;`

##### class Order

Заказ с номером столика `tableNumber` и временем исполнения заказа `time`

* Номер столика передается в конструкторе.
* Время исполнения заказа - рандомное.

##### class Table

Обслуживаемый столик с номером столика `private tableNumber`

* метод формирования заказа по номеру столика

##### class Dishes

* Готовое блюдо с номером столика

##### class Manager

Класс управления рестораном где:

1. Создается список из 10 столиков - `List<Table> restaurantTables`
2. Создается очередь с заказами `private final Queue<Order> orderQueue`.
3. Создается очередь с готовыми блюдами `private final Queue<Dishes> dishesQueue`.

> Прим. [Интерфейс Queue и Concurrent Collections] (https://dzone.com/refcardz/core-java-concurrency)

4. Синхронизируемый метод `getNextTable`, где мы получаем следующий столик к которому должен подойти официант за заказом. Официант ходит по кругу от 1 стола к 10.
5. Методы получения очереди с заказами `Queue<Order> getOrderQueue` и получения очереди с готовыми блюдами `Queue<Dishes> getDishesQueue`

##### class Waiter

Реализует действия Официанта

> исполняется в потоке.

* Инстанируем класс управления Manager
* Пока поток не остановлен или есть готовый заказ в очереди
    * Если есть готовый заказ в очереди `!manager.getDishesQueue().isEmpty()` - относим готовый заказ к столику.
        * Берем заказ из очереди готовых заказов `manager.getDishesQueue().poll()`
        * Получаем номер столика через готовый заказ `dishes.getTableNumber()`
        * Выводим сообщение что "Официант отнес заказ для стола №"
    * Иначе берем новый заказ
        * Подходим к очередному столику `manager.getNextTable()`
        * Создаем новый заказ `table.getOrder()`
        * Привязываем заказ к номеру столика `order.getTableNumber()`
        * Выводим сообщение что "Получен заказ от стола №"
        * добавляем заказ в очередь с заказами `manager.getOrderQueue().add(order)`
        
    * Даем задерку потока в 0,1 сек пока официант идет к следущему столу.
        
##### class Cook

Реализует действия Повара

> исполняется в потоке.

* Пока поток не остановлен или очередь заказов пуста
    * Если очередь заказов пуста `needToWait = !needToCookOrders()`
        * через каждые 0,1 сек выводим сообщение "Повар отдыхает"
    * Как только заказ появляется в очереди `!needToWait` выполняем метод `private void cooking()`
        * Инстанируем класс управления Manager
        * Берем заказ из очереди готовых заказов `manager.getDishesQueue().poll()`
        * Получаем номер столика `order.getTableNumber()` и время вывполнения заказа `order.getTime()`
        * Выводим сообщение "Заказ будет готовиться ... мс для стола №..."
        * Делаем задержку на время выполнения заказа `order.getTime()`
        * Готовим блюдо для столика из заказа `Dishes dishes = new Dishes(order.getTableNumber());`
        * Получаем номер столика `dishes.getTableNumber()`
        * Выводим сообщение "Заказ для стола №%d готов"
        
#### Текущий алгоритм программы

* В ресторане 10 столов
* Официант ходит по кругу от 1 стола к 10
    * Если есть готовый заказ официант:
        * берет заказ из очереди готовых заказов (блюд)
        * Относит заказ к столику
        * Сообщает что отнес готовый заказ для стола №
    * Иначе 
        * подходит к очередному столу
        * создает новый заказ
        * сообщает что принял новый заказ от стола №
        * добавляет его в очередь с заказами
    * идет к следующему столику
* Пока нет заказов в очереди повар отдыхает
* Как только появляется новый заказ в очереди заказов, повар:
    * берет заказ из очереди новых заказов
    * сообщает сколько по времени будет готовиться новый заказ для стола №
    * готовит заказ (блюдо)
    * сообщает что заказ для стола № готов
    
#### Ищем ошибку
 
> По условию официант почему-то не относит приготовленные блюда назад к столам.

По логике программы, - официант что бы отнести готовый заказ к столику должен взять его из очереди готовых заказов.
Но очередь готовых заказов пуста.

> Это можно проверить поставив breakpoint на `if (!manager.getDishesQueue().isEmpty())`
> или вывести условие на консоль `!manager.getDishesQueue().isEmpty()`

Повар, нехороший человек, не добавляет приготовленные заказы в очередь готовых заказов.
 
#### Исправляем

* Действия повара реализуютя в классе Cook, в методе `private void cooking()`
* В этом методе уже инстанирован объект Manager `Manager manager = Manager.getInstance()`
* Следовательно мы можем добавить готовый заказ в очередь `manager.getDishesQueue().add(dishes)` 